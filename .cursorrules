# Cursor Rules for Survival Syndicate Server

## Project Context

Survival Syndicate — online multiplayer survival game server. The architecture is split into **Central Zone (global scope)** and **Local Zones (zone scope, close to players)**. Services communicate via NATS; clients use HTTP for Central Zone APIs and WebSocket for Local Zone gameplay.

**Central Zone (Global Scope):**
- `api-gateway` — единая HTTP точка входа (см. `docs/architecture/17_api_reference.md`)
- `auth-service` — JWT выдача/валидация (см. `docs/mvp_plan.md`, `docs/architecture/30_api_and_websocket_contracts.md`)
- `matchmaking-service` — выбор зоны и выдача `websocketUrl` (см. `docs/mvp_plan.md`, `docs/architecture/29_nats_orchestrator_reporting_contract.md`)
- `player-service` — мета-прогрессия игрока (см. `docs/mvp_plan.md`, `docs/architecture/15_player_service.md`)
- `building-service` — мета: здания/улучшения (см. `docs/architecture/13_building_service.md`)
- `combat-progress-service` — мета: XP/Battle Pass/трофеи (см. `docs/architecture/14_combat_progress_service.md`)
- `scheduler-service` — cron/jobs (см. `docs/architecture/16_scheduler_service.md`)
- `collector-service` — сбор аналитики/ивентов в ClickHouse (см. `docs/architecture/05_analytics_and_events.md`, `docs/architecture/17_api_reference.md`)
- `payment-service` — валидация IAP (см. `docs/architecture/10_payment_validation_service.md`, `docs/architecture/17_api_reference.md`)
- `history-service` — запись реплеев/истории матчей (см. `docs/architecture/34_match_history_system.md`)

**Local Zone (Zone Scope):**
- `local-orchestrator` — управляет зоной и распределяет матчи (см. `docs/mvp_plan.md`, `docs/architecture/29_nats_orchestrator_reporting_contract.md`)
- `gameplay-service` — запускает/ведёт симуляции матчей (см. `docs/mvp_plan.md`, `docs/architecture/33_gameplay_service_internals.md`)
- `websocket-service` — держит WS-соединения и проксирует сообщения в зону (см. `docs/mvp_plan.md`, `docs/architecture/30_api_and_websocket_contracts.md`)

Naming note: legacy docs/code may mention `game-server` and `analytics-service`; in the Central/Zone model the real-time stack is split into `websocket-service` + `gameplay-service`, and analytics ingestion is `collector-service`.

**Tech Stack:** NestJS 11, TypeScript 5.7, Prisma 7, NATS, Redis, PostgreSQL 15, WebSocket, ClickHouse

## Per-App Documentation

Read `apps/{service}/FEATURES.md` when working in that app. Read `libs/LIBS.md` when using shared libraries. Read `docs/architecture/` for full system design (32 documents).

## Clean Architecture - STRICT ENFORCEMENT

**Layer Structure (Dependency Direction: Presentation → Application → Domain → Infrastructure)**

```
apps/{service}/src/
├── domain/              # Pure business logic, ZERO framework imports
│   ├── entities/        # Business entities with identity
│   └── services/        # Domain services
├── application/         # Orchestration layer
│   ├── use-cases/       # CQRS handlers (Commands/Queries)
│   └── ports/           # Abstract classes (NOT interfaces)
├── infrastructure/      # Technical implementations
│   ├── prisma/
│   │   ├── mapper/      # Entity ↔ Prisma conversions
│   │   └── repositories/
│   └── external/
└── presentation/
    ├── http/            # Controllers + DTOs
    ├── nats/            # Message handlers
    └── websocket/       # WebSocket handlers (game-server only)
```

**CRITICAL RULES:**
- Domain layer: NO NestJS imports, NO Prisma, NO framework code
- Business logic: ONLY in domain entities/services
- Application ports: MUST be abstract classes (not interfaces) for NestJS DI
- Handlers: Thin orchestrators (<50 lines)
- CQRS: Commands for writes, Queries for reads

## Path Aliases - USE THESE

```typescript
// Applications
@app/api-gateway/*
@app/auth-service/*
@app/player-service/*
@app/building-service/*
@app/combat-progress-service/*
@app/scheduler-service/*
@app/game-server/*
@app/analytics-service/*

// Libraries
@lib/shared/*              // Common utilities, auth, health, NATS client
@lib/lib-player/*          // Player service contracts
@lib/lib-building/*        // Building service contracts
@lib/lib-game-server/*     // Game server contracts
@lib/lib-combat-progress/* // Combat progress contracts
@lib/lib-analytics/*       // Analytics service contracts

// Prisma clients
@prisma/meta               // Player data, buildings, trophies, wallet
@prisma/catalog            // Static game config (building levels, weapon stats)
```

## NATS Communication - NEVER HARDCODE SUBJECTS

**ALWAYS use library contracts, NEVER hardcode subject strings.**

```typescript
// ✅ CORRECT: Use publisher from library
import { PlayerPublisher } from '@lib/lib-player';
const response = await playerPublisher.getCharacter(request);

// ❌ WRONG: Hardcoded subject
const response = await natsClient.send('player.get-character.v1', data);
```

**Communication Libraries:**
- `@lib/lib-player` — PlayerPublisher, PlayerSubjects
- `@lib/lib-building` — BuildingPublisher, BuildingSubjects
- `@lib/lib-game-server` — GameServerPublisher, GameServerSubjects
- `@lib/lib-combat-progress` — CombatProgressPublisher, CombatProgressSubjects
- `@lib/lib-analytics` — AnalyticsPublisher, AnalyticsSubjects

**Pattern:**
- Request-Reply: Publishers (synchronous)
- Pub/Sub: Subjects (async events)

### NATS Publisher Response Validation - MANDATORY

Every NATS publisher method in `/libs/lib-*/src/publishers` MUST:
1. Check if response exists: `if (!response) { throw ... }`
2. Validate response with Zod: `ResponseSchema.parse(response)`
3. Include error logging with context
4. Use try-catch around Zod validation

## Game Server Architecture

The `game-server` service is unique — it runs real-time gameplay simulations:

### Core Components
- **GameLoop**: Fixed tick rate (30 FPS), deterministic simulation
- **InputBuffer**: `Map<playerId, RingBuffer<PlayerInput>>` — last N inputs per player
- **StateBuffer**: `RingBuffer<WorldState>` — last N world states for lag compensation
- **PhysicsSystem**: Deterministic physics (movement, collisions)
- **LagCompensationSystem**: "Rewinds" world state for hit detection
- **CombatSystem**: Authoritative weapon fire, ammo, damage
- **AISystem**: Enemy behavior
- **SpawnSystem**: Wave-based enemy spawning

### Key Interfaces
```typescript
interface PlayerInput {
  sequence_id: number;
  client_time: number;
  ping: number;
  joystick_vector: { x: number; y: number };
  actions: Action[];
  states: { is_firing: boolean };
}

interface WorldState {
  server_time: number;
  entities: Map<entityId, EntityState>;
}
```

### Game Server Communication
- **WebSocket**: Receives `PlayerInput`, sends `WorldState`
- **NATS subscriptions**: `gameplay.start_simulation`, `player.input.{matchId}.*`
- **NATS publications**: `gameplay.world_state.{matchId}`

## Database Architecture

Two shared PostgreSQL databases:
- **Postgres_Meta** — Player data, buildings, trophies, achievements, wallet
- **Postgres_Catalog** — Static game config (building levels, weapon stats, enemy types)

```bash
# Generate Prisma clients
npm run prisma:generate

# Run migrations (dev)
npm run prisma:migrate:dev

# Prisma Studio
npm run prisma:studio:meta
npm run prisma:studio:catalog
```

## HTTP Controllers, DTOs, and Use Cases

### Controller Pattern
```typescript
@Controller('characters')
@ApiTags('Characters')
export class CharactersHttpController {
  private readonly logger = new Logger(CharactersHttpController.name);
  
  constructor(
    private readonly commandBus: CommandBus,
    private readonly queryBus: QueryBus,
  ) {}
  
  @Post()
  @ApiOperation({ summary: 'Create character' })
  @ApiResponse({ status: 201, type: CreateCharacterResponseDto })
  async create(
    @Body() dto: CreateCharacterHttpDto,
    @Req() request: Request,
  ): Promise<CreateCharacterResponseDto> {
    this.logger.log('Create character request');
    return this.commandBus.execute(
      new CreateCharacterCommand({ ...dto }),
    );
  }
}
```

### DTO Pattern (Zod + Swagger)
```typescript
import { z } from 'zod';
import { createZodDto } from '@anatine/zod-nestjs';
import { ApiProperty } from '@nestjs/swagger';

export const CreateCharacterRequestSchema = z.object({
  nickname: z.string().min(3).max(20),
  avatarUrl: z.string().url().optional(),
});

export type CreateCharacterRequestDto = z.infer<typeof CreateCharacterRequestSchema>;

export class CreateCharacterHttpDto extends createZodDto(
  CreateCharacterRequestSchema,
) {
  @ApiProperty({ description: 'Character nickname', example: 'ShadowBoss' })
  declare nickname: string;
}
```

## Testing

```bash
npm test              # Run all tests
npm run test:watch    # Watch mode
npm run test:cov      # Coverage
npm run test:e2e      # E2E tests
```

**Test Pyramid:** 70% unit, 20% integration, 10% E2E
**Quality First:** Test business logic and real-world scenarios, NOT trivial getters/setters.

## Development Workflow

**Adding New Feature:**
1. Identify owning service
2. Domain entities (domain layer)
3. Application ports as abstract classes
4. Use case handlers
5. Infrastructure implementations
6. HTTP/NATS controllers
7. Update library contracts if needed
8. Write tests
9. **MANDATORY:** Run `npm run lint`

## CRITICAL RULES — NEVER VIOLATE

**DO NOT:**
- Put business logic in application/infrastructure layers
- Use Prisma directly from handlers (use repositories via ports)
- Hardcode NATS subjects (use library contracts)
- Define ports as interfaces (use abstract classes for NestJS DI)
- Import framework code in domain layer
- Skip running `npm run lint` after code changes

**DO:**
- Keep handlers thin (<50 lines)
- Use CQRS (Commands for writes, Queries for reads)
- Use path aliases (@app/*, @lib/*, @prisma/*)
- Follow test pyramid
- Run `npm run lint` after EVERY code change
- Validate NATS publisher responses with Zod
- Use Zod schemas for DTO validation

## Documentation References

- Architecture docs: `docs/architecture/` (32 documents)
- Building Service: `docs/architecture/09_building_service.md`
- Combat Progress Service: `docs/architecture/10_combat_progress_service.md`
- Player Service: `docs/architecture/11_player_service.md`
- Scheduler Service: `docs/architecture/12_scheduler_service.md`
- Game loop: `docs/architecture/21_game_loop_best_practices.md`
- Service contracts: `docs/architecture/22_service_contracts.md`
- Gameplay internals: `docs/architecture/28_gameplay_service_internals.md`
- NATS best practices: `docs/architecture/15_nats_best_practices.md`
- WebSocket contracts: `docs/architecture/25_api_and_websocket_contracts.md`
- Connection handling: `docs/architecture/27_connection_handling.md`
