# Survival Syndicate: Гайд по разработке серверной части

Этот документ описывает ключевые принципы и лучшие практики, которых мы придерживаемся при разработке серверной архитектуры проекта.

## Часть 1: Философия

1.  **Простота > Сложность (Simple is better than complex)**
    -   Мы избегаем "магических" решений. Код должен быть читаемым и понятным даже для нового разработчика.
    -   Каждый микросервис решает одну, четко определенную задачу (Single Responsibility Principle).

2.  **Явное > Неявное (Explicit is better than implicit)**
    -   Все зависимости должны быть явно объявлены. Мы избегаем глобальных состояний.
    -   Контракты взаимодействия между сервисами (gRPC API, сообщения в NATS) должны быть строго определены через Protobuf.

3.  **Конфигурация через окружение**
    -   Никаких жестко закодированных адресов, портов или токенов в коде. Вся конфигурация передается через переменные окружения, что является стандартом для работы в Kubernetes.

4.  **Единообразие логирования**
    -   Все сервисы пишут структурированные (JSON) логи в `stdout`.
    -   Каждая запись лога содержит минимальный набор полей: `level` (info, warn, error), `timestamp`, `service_name`, `message`.

5.  **Отказоустойчивость по умолчанию**
    -   Любой сетевой вызов обрабатывается с учетом возможных сбоев: используются `retries` (повторные попытки) с `exponential backoff` и `timeouts` (таймауты).
    -   Сервисы спроектированы так, чтобы успешно стартовать и пытаться переподключиться к зависимостям (БД, NATS), даже если те временно недоступны.

---

## Часть 2: Асинхронное взаимодействие (NATS)

NATS — наша основная "нервная система" для асинхронного обмена сообщениями между сервисами.

1.  **Гарантированная доставка (JetStream)**
    -   Для всех критически важных бизнес-событий (создание игрока, обновление валюты, команды матчмейкинга) **обязательно** используется NATS JetStream для гарантии доставки.
    -   Core NATS ("огонь-и-забыл") используется только для некритичных данных (например, метрики).

2.  **Именование тем (Subjects)**
    -   Мы придерживаемся строгой схемы именования для всех тем:
        `{сервис}.{тип_события}.{объект}.{действие}`
    -   **Примеры:** `player.event.currency.updated`, `matchmaker.command.room.create`.

3.  **Контракты сообщений (Protobuf)**
    -   Все сообщения, передаваемые через NATS, **должны быть** сериализованы с помощью Protobuf. Использование сырого JSON запрещено.
    -   `.proto` файлы являются единым источником правды для контрактов и хранятся в отдельном `common-proto` репозитории.

---

## Часть 3: Синхронное взаимодействие (gRPC)

gRPC — наш стандарт для **синхронного** взаимодействия "сервис-сервис" внутри кластера. Он **не должен** быть доступен извне.

1.  **Сценарии использования**
    -   Используется, когда сервису нужно **немедленно** получить данные от другого для продолжения операции (например, `GameSession` запрашивает инвентарь у `PlayerService` перед началом матча).
    -   gRPC предназначен для высокопроизводительных внутренних API, где ожидание асинхронного ответа неприемлемо.

2.  **Определение сервисов (Protobuf)**
    -   gRPC-сервисы, их методы и структуры данных также определяются в `.proto` файлах. Это позволяет генерировать типизированные клиентские и серверные заготовки на любом языке.

3.  **Дедлайны и ошибки**
    -   Каждый gRPC вызов **обязан** иметь `deadline` (максимальное время ожидания ответа) для предотвращения каскадных сбоев.
    -   Сервисы должны возвращать стандартизированные коды ошибок gRPC (e.g., `NOT_FOUND`, `PERMISSION_DENIED`) для предсказуемой обработки ошибок на стороне клиента.
