# Обработка дисконнекта и реконнекта

Этот документ описывает, как система обрабатывает непредвиденную потерю соединения с клиентом и его попытки вернуться в игру.

## Основные принципы

-   **Сохранение состояния:** Игрок не "удаляется" из матча сразу после дисконнекта. Сервер резервирует за ним место в течение определенного времени.
-   **Безопасный реконнект:** Вернувшийся игрок должен подтвердить свою личность, чтобы не "угнать" чужую сессию.
-   **Быстрое восстановление:** После реконнекта игрок должен немедленно получить актуальное состояние мира, чтобы продолжить игру.

---

## 1. Логика на стороне WebSocket Service

#### Обнаружение дисконнекта
-   `WebSocket Service` обнаруживает разрыв соединения (событие `on:close` сокета).
-   Он **не удаляет** информацию об игроке, а лишь помечает его как `disconnected`.
-   Сервис публикует внутреннее событие в NATS.

#### NATS Publication (при дисконнекте)

-   **Тема:** `player.connection.status`
-   **Payload:**
    ```json
    {
      "playerId": "string",
      "matchId": "string",
      "status": "disconnected"
    }
    ```

---

## 2. Логика на стороне Local Orchestrator

-   **Таймер "Grace Period":**
    -   Оркестратор слушает события `player.connection.status`.
    -   Получив `status: "disconnected"`, он запускает для этого игрока таймер (например, на 60 секунд).
    -   Если за это время игрок не вернется, Оркестратор отправит команду в `Gameplay Service` на окончательное удаление игрока из матча.

---

## 3. Процесс реконнекта (со стороны клиента)

1.  Клиент обнаруживает разрыв соединения.
2.  Он пытается переподключиться к тому же `websocketUrl`, который получил от Матчмейкера.
3.  **Сразу после подключения** он отправляет **новое** аутентификационное сообщение.

### WebSocket: `client.reconnect` (Клиент -> Сервер)

-   **Назначение:** Попытка вернуться в существующий матч. **Должно быть первым сообщением** при переподключении.
-   **Payload:**
    ```json
    {
      "type": "reconnect",
      "token": "string" 
    }
    ```
    -   `token`: Тот же самый `accessToken` (JWT), который использовался для входа.

---

## 4. Логика на стороне WebSocket Service (при реконнекте)

1.  Сервис получает сообщение `client.reconnect`.
2.  Он валидирует JWT, извлекает `playerId`.
3.  Через NATS он обращается к `Local Orchestrator` с запросом.

### NATS Request (WebSocket -> Оркестратор)

-   **Тема:** `orchestrator.player.reconnect_request`
-   **Payload:**
    ```json
    {
      "playerId": "string"
    }
    ```

### Логика Оркестратора (ответ на запрос)

-   Оркестратор проверяет:
    -   Знает ли он этого `playerId`?
    -   Находится ли этот игрок в статусе `disconnected`?
    -   Не истек ли таймер "grace period"?
-   **Если все проверки пройдены:**
    -   Оркестратор останавливает таймер на удаление.
    -   Отвечает `WebSocket Service` успехом, передавая `matchId`.
-   **Если нет:**
    -   Отвечает ошибкой.

### Финальные шаги

-   Получив успех от Оркестратора, `WebSocket Service` отправляет клиенту `server.reconnect.success` (аналогично `authenticate.success`) и начинает обычный обмен `WorldState`.
-   Сервис также публикует событие `player.connection.status` со статусом `reconnected`, чтобы Оркестратор и другие сервисы знали, что игрок вернулся.
