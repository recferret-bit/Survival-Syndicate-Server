# 41. Серверный мониторинг, логирование и Health Checks

## 1. Фундаментальная философия: Три столпа наблюдаемости (Observability)

1.  **Логи (Logs):** Что произошло? Записи о конкретных событиях.
2.  **Метрики (Metrics):** Как система себя чувствует? Агрегированные числовые данные (CPU, RAM, RPS).
3.  **Трейсы (Traces):** Где была проблема? Путь одного запроса через несколько микросервисов. (Для старта мы сфокусируемся на логах и метриках).

## 2. Логирование: ELK Stack (или аналог)

Хранить логи в файлах на каждом инстансе — плохая практика. Нам нужна централизованная система.

-   **Стек:** Классический стек **ELK (Elasticsearch, Logstash, Kibana)** или его современные аналоги (Loki, Fluentd).
-   **Как это работает:**
    1.  **Приложение (Node.js):** Каждый микросервис **не пишет логи в файл**. Он пишет их в `stdout` (стандартный вывод) в формате **JSON**.
    2.  **Сборщик (Fluentd/Logstash):** В нашем k8s-кластере будет запущен агент, который автоматически собирает `stdout` из всех контейнеров.
    3.  **Агрегатор (Elasticsearch/Loki):** Сборщик отправляет JSON-логи в центральное хранилище, которое индексирует их для быстрого поиска.
    4.  **Визуализатор (Kibana):** Веб-интерфейс для поиска, фильтрации и визуализации логов.

**Best Practice (JSON-логи):**
```typescript
// Вместо console.log('Player connected');
logger.info({
  message: 'Player successfully connected to match',
  match_id: '...',
  user_id: '...'
});
```
Это позволяет нам легко фильтровать логи по `user_id` или `match_id`.

## 3. Метрики: Prometheus + Grafana

Это стандарт индустрии для сбора и визуализации метрик.

### 3.1. Архитектура
1.  **Exporter:** Каждый наш микросервис (на Node.js) будет использовать библиотеку (например, `prom-client`) для предоставления эндпоинта `/metrics`. При обращении на этот эндпоинт, сервис отдает текстовый ответ с текущими значениями метрик (CPU, RAM, количество активных WebSocket-соединений и т.д.).
2.  **Node Exporter:** На каждом VPS будет запущен агент, который предоставляет метрики самой операционной системы (загрузка диска, сети).
3.  **Prometheus Server:** Центральный сервер, который периодически (раз в 15 секунд) "опрашивает" (`scrapes`) все `/metrics` эндпоинты и сохраняет значения в свою time-series базу данных.
4.  **Grafana:** Веб-интерфейс, который подключается к Prometheus как к источнику данных и позволяет строить красивые и информативные дашборды.
5.  **Alertmanager:** Компонент Prometheus, который будет отправлять алерты (в Telegram, Slack, PagerDuty), если какая-то метрика выйдет за пределы нормы (например, `CPU > 90%` в течение 5 минут).

## 4. Health Checks: Разделение `health` и `ping`

Как вы и предложили, мы разделим проверки на внутренние и внешние.

### 4.1. `GET /ping`
-   **Назначение:** Простая, легковесная проверка того, что сервис **запущен и отвечает**.
-   **Логика:** **Никаких** проверок зависимостей. Просто возвращает `200 OK` и, возможно, статус "pong".
-   **Кто использует:** Другие микросервисы для проверки доступности соседа. Kubernetes для базовых `liveness probes`.

### 4.2. `GET /health`
-   **Назначение:** Глубокая, комплексная проверка того, что сервис **полностью работоспособен** и готов принимать трафик.
-   **Логика:** Последовательно проверяет все свои критические зависимости.
-   **Пример для `Matchmaking Service`:**
    1.  Проверить соединение с `Postgres_Users`.
    2.  Проверить соединение с `NATS`.
    3.  Проверить, что в его кэше есть данные хотя бы от одного `Game Server` (чтобы убедиться, что NATS-подписка работает).
-   **Ответ:**
    -   Если **все** проверки прошли — `200 OK` с детальным JSON:
        ```json
        {
          "status": "ok",
          "dependencies": {
            "postgres": "ok",
            "nats": "ok"
          }
        }
        ```
    -   Если **хотя бы одна** проверка провалилась — `503 Service Unavailable` с деталями ошибки.
-   **Кто использует:** Kubernetes для `readiness probes`. Если `/health` возвращает ошибку, Kubernetes временно убирает этот инстанс сервиса из-под балансировщика нагрузки, давая ему время на восстановление, и не направляет на него новый трафик.
