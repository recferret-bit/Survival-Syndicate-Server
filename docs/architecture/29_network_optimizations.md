# 29. Сетевые оптимизации (v3 - Восстановленная)

## 1. Обзор текущих проблем

Текущий сетевой протокол спроектирован для простоты, но не для эффективности. Он имеет две фундаментальные проблемы.

### Проблема №1: Избыточность данных
-   **Что происходит:** Каждые 100 мс сервер отправляет **полное** состояние мира (`WORLD_STATE`).
-   **Почему это плохо:** Если из 100 врагов сдвинулся только один, мы все равно отправляем данные о всех 100. 99% трафика — мусор.

### Проблема №2: Нерелевантность данных
-   **Что происходит:** **Все** клиенты получают **одинаковый** `WORLD_STATE`.
-   **Почему это плохо:** Игроку в левой части карты не нужно знать о пуле, летящей в правой части. Это лишний трафик и уязвимость для map-хаков.

---

## 2. Решение №1: Delta Compression (Борьба с избыточностью)

**Идея:** Отправлять не все состояние, а **только то, что изменилось**.

### Best Practice: State Masking / "Dirty" Flags

**На Сервере:**
1.  Сервер для каждого клиента хранит `lastSentState` (копию того, что отправил в последний раз).
2.  Перед отправкой он сравнивает `currentState` с `lastSentState`.
3.  Он создает легковесный `deltaState`, содержащий **только отличающиеся поля**.
4.  Отправляет `deltaState`.
5.  Обновляет `lastSentState`.

**На Клиенте:**
1.  Клиент получает `deltaState` и "мерджит" его, точечно обновляя свое локальное состояние мира.

---

## 3. Решение №2: Interest Management (Борьба с нерелевантностью)

**Идея:** Каждый клиент получает **персонализированный** срез мира.

### Best Practice: Radius-Based Interest Management

Это гибкий и простой в реализации подход, идеально подходящий для нашей игры.

#### Как это работает (Сервер)
1.  **Определение радиуса:** В `GameConfig` определяется глобальная переменная `INTEREST_RADIUS` (например, 2000 пикселей, что примерно равно диагонали двух стандартных экранов).
2.  **Персонализация пакета:** Для **каждого** клиента перед отправкой пакета сервер выполняет следующий алгоритм:
    -   Берет позицию этого игрока (`player.position`).
    -   Итерируется по всем динамическим объектам в мире.
    -   Если дистанция от игрока до объекта **меньше или равна** `INTEREST_RADIUS`, этот объект включается в список для дальнейшей обработки.

#### Глобальные и важные события
-   Сущности и события на сервере должны иметь флаг `isGlobal` (например, "база захвачена"), который позволяет им игнорировать Interest Management и рассылаться всем.

---

## 4. Обновленный план разработки сервера

План из `GDD/28` расширяется.

### Фаза 2: Физика и **продвинутая сеть**
1.  Интегрировать `collision_utils.ts`.
2.  **Реализовать `DeltaStateGenerator`:** Сервис, который сравнивает два состояния и создает `deltaState`.
3.  **Реализовать `InterestManager`:** Сервис, который использует Radius-Based подход для определения зоны интереса.
4.  **Модифицировать сетевой слой:** Вместо рассылки общего `WORLD_STATE`, теперь он должен для каждого игрока:
    -   Вызвать `InterestManager`, чтобы получить список релевантных сущностей.
    -   Вызвать `DeltaStateGenerator`, чтобы создать персонализированный `deltaState`.
    -   Отправить этот `deltaState`.
5.  Реализовать `LagCompensationSystem`.
