# Best Practices: Game Loop в Node.js

Этот документ описывает рекомендуемые подходы к реализации игрового цикла (`GameLoop`) на Node.js, учитывая наши требования: поддержка фиксированного `tick rate` и одновременная работа нескольких независимых инстансов симуляции внутри одного `Gameplay Service`.

## Основная проблема

Node.js является однопоточным. "Классический" `while(true)` цикл заблокирует весь `event loop` и не позволит сервису обрабатывать сетевые запросы или другие I/O операции. Поэтому нам нужны неблокирующие подходы.

---

## Подходы к реализации

### Подход 1: Один таймер на все инстансы (`setInterval`)

В этом подходе мы создаем **один глобальный таймер** на весь `Gameplay Service`, который срабатывает с нужной нам частотой (например, 30 раз в секунду).

```javascript
// gameplay.service.ts

const TICK_RATE = 30;
const TICK_INTERVAL = 1000 / TICK_RATE;

class GameplayService {
  private gameInstances = new Map<string, GameSimulation>();

  constructor() {
    setInterval(() => {
      const deltaTime = TICK_INTERVAL / 1000; // в секундах
      for (const simulation of this.gameInstances.values()) {
        simulation.update(deltaTime);
      }
    }, TICK_INTERVAL);
  }

  // ... методы для добавления/удаления симуляций
}
```

**Плюсы:**
-   **Простота:** Очень легко реализовать и поддерживать.
-   **Синхронизация:** Все симуляции обновляются одновременно, что может быть полезно для будущих кросс-игровых механик.
-   **Эффективность:** Только один таймер на весь процесс, минимальные накладные расходы.

**Минусы:**
-   **Дрейф времени (Time Drift):** `setInterval` не гарантирует точное время вызова. Если одна из симуляций `simulation.update()` будет выполняться дольше, чем `TICK_INTERVAL`, следующий тик будет отложен, и со временем накопится ошибка.
-   **Связанность:** "Тяжелая" симуляция может "затормозить" все остальные, так как они выполняются последовательно в одном колбэке.

---

### Подход 2: Независимые таймеры с компенсацией дрейфа (рекомендуется)

Каждый инстанс симуляции управляет своим собственным жизненным циклом, используя `setTimeout` и отслеживая реальное прошедшее время.

```javascript
// game_simulation.ts

const TICK_RATE = 30;
const TICK_INTERVAL = 1000 / TICK_RATE;

class GameSimulation {
  private lastTickTime: number;
  private isRunning = false;

  constructor() {
    this.lastTickTime = Date.now();
  }

  start() {
    this.isRunning = true;
    this.tick();
  }

  stop() {
    this.isRunning = false;
  }

  private tick() {
    if (!this.isRunning) return;

    const now = Date.now();
    const deltaTime = (now - this.lastTickTime) / 1000; // реальное прошедшее время

    this.update(deltaTime);

    this.lastTickTime = now;

    const nextTickTime = now + TICK_INTERVAL;
    const timeout = Math.max(0, nextTickTime - Date.now());

    setTimeout(() => this.tick(), timeout);
  }

  update(deltaTime: number) {
    // ... логика симуляции ...
  }
}
```

**Плюсы:**
-   **Точность:** Этот подход **самокорректируется**. Даже если `update` занимает больше времени, `deltaTime` всегда будет отражать реальное прошедшее время, а `setTimeout` будет запланирован так, чтобы в среднем поддерживать нужный `tick rate`.
-   **Независимость:** Каждый `GameLoop` работает в своем собственном "ритме". Проблемы в одном инстансе не влияют на тайминги других.
-   **Гибкость:** Позволяет в будущем иметь инстансы с разным `tick rate`, если потребуется.

**Минусы:**
-   **Чуть сложнее:** Требует больше кода для управления каждым инстансом.
-   **Больше таймеров:** Теоретически, создает больше объектов таймеров в Node.js `event loop`, но на практике это незначительные накладные расходы.

---

## Итоговая рекомендация

**Подход 2 (Независимые таймеры с компенсацией дрейфа)** является предпочтительным и рекомендованным для нашей архитектуры.

Он обеспечивает необходимую **точность и изоляцию** для каждой игровой симуляции, что критически важно для детерминизма и стабильности геймплея. Простота `setInterval` не окупает риски, связанные с накоплением ошибки времени и взаимным влиянием симуляций друг на друга.
