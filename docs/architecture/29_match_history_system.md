# Система истории матчей (Replays)

Этот документ описывает архитектуру для сбора, транспортировки и хранения полной истории каждого матча для последующего анализа и воспроизведения (реплеев).

## 1. Сбор данных в `Gameplay Service`

В каждом инстансе `GameSimulation` необходимо собирать следующие данные на протяжении всего матча:

-   **Начальные параметры (Seed):**
    -   `randomSeed`: Число (`number`), которое использовалось для инициализации генератора псевдослучайных чисел (например, для разброса пуль, спавна лута). Это ключ к детерминированному воспроизведению.
    -   `matchConfig`: Объект с настройками матча (карта, режим и т.д.).

-   **Ввод игроков (Inputs):**
    -   Полная последовательность всех `PlayerInput`, полученных от всех игроков, с **серверными временными метками**.
    -   Структура: `[{ timestamp: 1676738787123, playerId: "p1", input: {...} }, ...]`

-   **Серверные события (Events):**
    -   Все значимые события, которые генерирует сервер в ходе симуляции, с временными метками. Например: `player_damage`, `enemy_spawn`, `item_pickup`.
    -   **Важно:** Сюда не нужно писать всё подряд. Только события, которые не могут быть детерминировано воспроизведены только на основе `randomSeed` и `PlayerInput`.

## 2. Формат данных: "Replay Object"

Когда матч завершается, `GameSimulation` собирает все накопленные данные в один большой JSON-объект.

```json
{
  "matchId": "string",
  "startTime": "ISO_datetime",
  "durationMs": "number",
  "matchConfig": { ... },
  "randomSeed": 123456789,
  "players": ["playerId1", "playerId2", ...],
  "inputs": [
    { "t": 50, "p": "p1", "d": { "mov": {"x":1}, ... } },
    { "t": 100, "p": "p2", "d": { "act": ["shoot"] } }
  ],
  "serverEvents": [
    { "t": 1500, "type": "enemy_spawn", "enemyId": "e1" }
  ],
  "endState": { ... } // Итоговые результаты матча
}
```
*(поля `t`, `p`, `d` — сокращения для экономии места)*

## 3. Транспортировка

1.  После завершения матча `Gameplay Service` формирует "Replay Object".
2.  Он публикует этот объект в специальную тему в **глобальном NATS**.

#### NATS Publication

-   **Тема:** `match.history.new`
-   **Payload:** "Replay Object" (в виде JSON-строки).

## 4. Хранилище: ClickHouse

Для этой задачи ClickHouse подходит **идеально**.

**Почему:**
-   **Колонко-ориентированная СУБД:** Она создана для быстрой вставки и агрегации огромных объемов данных, что идеально для потока событий от матчей.
-   **Сжатие:** Отлично сжимает данные, особенно повторяющиеся (например, `playerId` в `inputs`).
-   **Аналитика:** Позволяет мгновенно выполнять сложные аналитические запросы (например, "посчитать средний K/D для всех матчей на карте X за последний час").

### Отдельный сервис: `History Service`

Чтобы не нагружать `Gameplay Service` логикой работы с БД, создается отдельный микросервис.

-   **`History Service`:**
    1.  Подписывается на тему `match.history.new` в NATS.
    2.  При получении "Replay Object", он преобразует его в нужный формат и **пакетно вставляет** в ClickHouse.

### Схема таблицы в ClickHouse

```sql
CREATE TABLE match_replays (
    match_id String,
    start_time DateTime,
    duration_ms UInt32,
    
    -- Конфигурация матча в виде JSON
    match_config String,
    random_seed UInt64,

    -- Данные для быстрого поиска и фильтрации
    players Array(String),
    
    -- "Тяжелые" данные
    inputs String,      -- Массив инпутов как JSON-строка
    server_events String, -- Массив событий как JSON-строка
    end_state String,     -- JSON-строка с результатами

    -- Для партиционирования
    event_date Date DEFAULT toDate(start_time)

) ENGINE = MergeTree()
PARTITION BY toYYYYMM(event_date)
ORDER BY (match_id, start_time);
```

**Особенности схемы:**
-   Ключевые поля для фильтрации (`match_id`, `start_time`, `players`) вынесены в отдельные колонки.
-   "Тяжелые" массивы (`inputs`, `serverEvents`) хранятся как сжатые JSON-строки, чтобы не перегружать схему. Их можно будет парсить при необходимости на лету во время запроса.
