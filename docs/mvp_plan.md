# MVP План: "Каркас" серверной архитектуры

## 1. Цель MVP

Основная цель этого MVP — **проверить и отладить всю межсервисную коммуникацию**, описанную в архитектурных документах, без реализации сложной игровой логики (`GameLoop`).

Мы создадим "заглушки" для всех ключевых сервисов, научим их общаться друг с другом через NATS и HTTP, и убедимся, что полный цикл от поиска матча до его (фейкового) завершения работает.

## 2. Список сервисов в MVP

### А. Центральная Зона (Global Scope)

1.  **Auth Service:**
    -   **Задача:** Выдача JWT токенов по `username`.
    -   **Контракт:** `POST /api/auth/login`.

2.  **Matchmaking Service:**
    -   **Задача:** Прием запросов на поиск игры и "распределение" игроков по Локальным Зонам.
    -   **Контракты:**
        -   `POST /api/matchmaking/join` (HTTP).
        -   Подписка на `orchestrator.zone.heartbeat` (NATS).

### Б. Локальная Зона (Zone Scope)

1.  **Local Orchestrator:**
    -   **Задача:** Управляет своей Зоной, общается с Матчмейкером.
    -   **Контракты:**
        -   Публикация `orchestrator.zone.heartbeat` (NATS).
        -   Подписка на `gameplay.service.heartbeat` (NATS).

2.  **Gameplay Service:**
    -   **Задача:** Имитирует управление инстансами игр (без реальной симуляции).
    -   **Контракты:**
        -   Публикация `gameplay.service.heartbeat` (NATS).
        -   Подписка на NATS-команды от Оркестратора.

3.  **WebSocket Service:**
    -   **Задача:** Управляет WebSocket-соединениями игроков.
    -   **Контракты:**
        -   Прием `client.authenticate`.
        -   Простая пересылка "эхо" сообщений для проверки связи.

## 3. Задачи для реализации (Таск-борд)

### Epic 1: Базовая инфраструктура

-   [ ] **TASK-1.1:** Создать Monorepo-структуру проекта с помощью NestJS CLI.
-   [ ] **TASK-1.2:** Настроить Docker Compose для запуска всех сервисов MVP и NATS.
-   [ ] **TASK-1.3:** Создать общую `libs` библиотеку для DTO и контрактов.

### Epic 2: Реализация сервисов-"заглушек"

-   [ ] **TASK-2.1:** **Auth Service:** Реализовать `POST /api/auth/login`, который генерирует валидный JWT.
-   [ ] **TASK-2.2:** **Matchmaking Service:**
    -   Реализовать `POST /api/matchmaking/join` (валидация JWT).
    -   Реализовать подписчика на `orchestrator.zone.heartbeat`, который будет хранить состояние Зон в памяти.
    -   При запросе на `join` выбирать первую доступную Зону и возвращать ее `websocketUrl`.
-   [ ] **TASK-2.3:** **Local Orchestrator:**
    -   Реализовать публикатор `orchestrator.zone.heartbeat` (отправляет фейковые данные каждые 5 сек).
    -   Реализовать подписчика на `gameplay.service.heartbeat` (просто логирует полученные данные).
-   [ ] **TASK-2.4:** **Gameplay Service:**
    -   Реализовать публикатор `gameplay.service.heartbeat` (отправляет фейковые данные каждые 5 сек).
-   [ ] **TASK-2.5:** **WebSocket Service:**
    -   Реализовать прием WebSocket-соединений.
    -   Реализовать обработку сообщения `client.authenticate` (валидация JWT).
    -   Реализовать простое "эхо" (отправлять обратно все, что пришло от клиента) для проверки связи.

### Epic 3: Интеграционное тестирование

-   [ ] **TASK-3.1:** Написать e2e тест (например, на Jest), который симулирует полный цикл:
    1.  Получить JWT в `Auth Service`.
    2.  С этим JWT пойти в `Matchmaking Service` и получить адрес Зоны.
    3.  Подключиться по WebSocket, отправить JWT.
    4.  Получить ответное сообщение об успехе.
    5.  Отправить тестовое сообщение и получить "эхо".
